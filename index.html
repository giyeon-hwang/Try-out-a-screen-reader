<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>스크린 리더 미션: 베이컨 토마토 디럭스 햄버거 가격은 얼마?</title>
    <style>
        /* 1. Global Resets & Base Styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            /* 터치 시 하이라이트 제거 */
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
                         Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            line-height: 1.6;
            background-color: #ffffff; /* 기본 흰색 배경 */
            color: #333;
            overflow: hidden; /* 기본 스크롤 방지 (JS로 제어 가정) */
            /* touch-action: none; /* 사용하지 않음 - JS에서 preventDefault로 제어 */
        }

        #app-container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            position: relative; /* 자식 요소 포지셔닝 기준 */
            height: 100%; /* 터치 영역 확보 */
            overflow: hidden; /* 내부 스크롤 방지 */
        }

        h1 {
            font-size: 1.5em;
            margin-bottom: 1em;
            color: #2c3e50;
            text-align: center;
            /* 기본 스타일 유지 (공간 차지) */
            padding: 10px 0;
        }

        /* --- 터치 탐색 시뮬레이션용 --- */
        /* invisible-but-interactive 클래스: 시각적으로 투명하지만 공간 차지 및 이벤트 감지 */
        .invisible-but-interactive {
            opacity: 0 !important; /* 투명 처리 */
            pointer-events: auto; /* 투명해도 이벤트 받도록 보장 */
            /* 영역 확인용 임시 스타일 (디버깅 시 주석 해제) */
            /* background-color: rgba(255, 0, 0, 0.05);
            border: 1px dashed red; */
        }

        /* 포커스 시각적 표시 (디버깅용) */
        .has-focus {
             /* 기본 아웃라인 사용 또는 커스텀 스타일 */
             /* outline: 3px solid rgba(0, 123, 255, 0.5); */
             /* box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.5); */
        }


        /* 2. Button Base Styles */
        .btn {
            display: block; /* 버튼 기본 block */
            width: 100%;
            padding: 12px 15px;
            margin-bottom: 10px;
            font-size: 1em;
            font-weight: 500;
            text-align: center;
            cursor: default; /* 터치 환경에서는 포인터 불필요 */
            border: 1px solid #e0e0e0; /* 영역 유지를 위한 테두리 (투명 처리됨) */
            border-radius: 8px;
            background-color: transparent; /* 배경 투명 */
            color: transparent; /* 텍스트 투명 */
            position: relative; /* 내부 요소 포지셔닝 기준 */
            /* 기본 버튼 모양 제거 */
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
        }

        /* 보이는 버튼 예외 처리 (Next 버튼) */
        .btn:not(.invisible-but-interactive) {
            background-color: #007bff;
            color: white;
            border: none;
            opacity: 1;
            cursor: pointer; /* 보이는 버튼은 클릭 가능 표시 */
        }
         /* 보이는 버튼 활성 상태 */
        .btn:not(.invisible-but-interactive):active {
            background-color: #0056b3;
            transform: scale(0.98);
        }

        /* 3. Home Screen Specific Styles */
        #home-screen {
            /* 기본적으로 표시 */
        }
        #home-screen h1 {
             /* 공간 확보 외 특별한 스타일 불필요 */
        }
        .category-buttons .btn {
            /* invisible-but-interactive 클래스 적용 */
        }


        /* 4. Modal Styles */
        .modal {
            display: none; /* JS로 제어 */
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* 모달 자체 스크롤 방지 */
            background-color: rgba(255, 255, 255, 0.95); /* 배경 약간 불투명 흰색 */
            padding: 20px;
        }

        .modal.modal-open {
            display: block; /* JS로 열 때 표시 */
        }

        /* JS가 모달 열 때 app-container에 이 클래스를 추가하여 홈 숨김 */
        #app-container.modal-active #home-screen {
             display: none; /* 홈 화면 레이아웃에서 제거 */
        }

        .modal-content {
            position: relative;
            background-color: transparent; /* 모달 컨텐츠 배경 투명 */
            height: 100%;
            overflow-y: auto; /* 내용 많을 경우 내부 스크롤 (필요 시) - 현재는 불필요할 듯 */
        }

        .modal-content h1 {
            font-size: 1.3em;
            text-align: left;
            /* invisible-but-interactive 클래스 적용 */
            border: none;
            background: none;
        }

        /* 5. Modal Button Specific Styles */
        /* 뒤로가기 버튼(.btn-back) */
        .modal-content .btn-back {
            width: auto;
            display: inline-block;
            padding: 8px 15px;
            margin-bottom: 15px;
            font-size: 0.9em;
             /* invisible-but-interactive 클래스 적용 */
        }

        /* "다음" 버튼 스타일 (시각적으로 보여야 함) */
        .modal-content .btn-next {
            width: auto;
            display: inline-block;
            padding: 12px 25px;
            font-size: 1em;
             /* .btn:not(.invisible-but-interactive) 스타일 적용됨 */
        }

        /* 모달 푸터 스타일 */
        .modal-footer {
             margin-top: 20px;
             padding-top: 15px;
             border-top: 1px solid transparent; /* 구분선 영역 확보 (투명 처리) */
             text-align: right; /* 다음 버튼 오른쪽 정렬 */
        }

        /* 6. Checkbox Item Styles */
        .checkbox-item {
            /* invisible-but-interactive 클래스 적용 */
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            padding: 12px;
            border: 1px solid #e0e0e0; /* 영역 유지를 위한 테두리 */
            border-radius: 6px;
            background-color: transparent; /* 배경 제거 */
        }

        .checkbox-item input[type="checkbox"] {
            opacity: 0; /* 체크박스 자체도 투명하게 */
            margin-right: 12px;
            flex-shrink: 0;
            width: 1.5em; /* 터치 영역 고려 */
            height: 1.5em; /* 터치 영역 고려 */
            pointer-events: auto; /* 이벤트 받을 수 있도록 */
             /* 기본 체크박스 모양 제거 시도 */
             appearance: none;
             -webkit-appearance: none;
             position: relative; /* 가상 요소 배치 기준 */
        }

        .checkbox-item label {
             opacity: 0; /* 라벨 텍스트도 투명하게 */
             flex-grow: 1;
             font-size: 0.95em;
             pointer-events: none; /* label 클릭은 checkbox로 전달되도록 */
             /* color: transparent; /* invisible 클래스가 처리 */
             padding: 5px 0; /* 높이 확보 */
        }

        /* 7. 알림 메시지 컨테이너 스타일 */
        #alert-container {
            position: fixed;
            bottom: 20px; /* 하단에 표시 */
            left: 50%;
            transform: translateX(-50%);
            z-index: 2000;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            /* 기본적으로 숨김, JS로 제어 */
            display: none;
            /* aria-live를 위해 DOM에는 존재해야 함 */
            pointer-events: none; /* 사용자가 건드릴 수 없도록 */
        }

    </style>
</head>
<body>
    <div id="alert-container" role="alert" aria-live="assertive"></div>

    <div id="app-container">
        <div id="home-screen">
            <h1 class="invisible-but-interactive" tabindex="0">베이컨 토마토 디럭스 햄버거 가격은 얼마?</h1>
            <div class="category-buttons">
                <button id="btn-category-fresh" class="btn invisible-but-interactive" tabindex="0">신선 식품</button>
                <button id="btn-category-dairy" class="btn invisible-but-interactive" tabindex="0">요거트/유제품</button>
                <button id="btn-category-fastfood" class="btn invisible-but-interactive" tabindex="0">패스트푸드</button>
                <button id="btn-category-seafood" class="btn invisible-but-interactive" tabindex="0">수산물</button>
                <button id="btn-category-processed" class="btn invisible-but-interactive" tabindex="0">가공식품</button>
                <button id="btn-category-icecream" class="btn invisible-but-interactive" tabindex="0">아이스크림</button>
            </div>
        </div>

        <div id="modal-fresh" class="modal" aria-hidden="true" role="dialog" aria-label="신선 식품 카테고리">
            <div class="modal-content">
                 <button id="btn-back-from-fresh" class="btn btn-back invisible-but-interactive" tabindex="0">뒤로가기</button>
                 <h1 class="invisible-but-interactive" tabindex="0">신선 식품 카테고리</h1>
                <form id="form-fresh">
                     <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-fresh-1" name="fresh_items" value="15900" tabindex="0">
                        <label for="chk-fresh-1" id="lbl-fresh-1">GAP 인증 설향 딸기 500 그램 15,900 원</label>
                    </div>
                    <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-fresh-2" name="fresh_items" value="3500" tabindex="0">
                        <label for="chk-fresh-2" id="lbl-fresh-2">쌈채소 모듬 3,500 원</label>
                    </div>
                    <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-fresh-3" name="fresh_items" value="18800" tabindex="0">
                        <label for="chk-fresh-3" id="lbl-fresh-3">국내산 냉장 삼겹살 600 그램 18,800 원</label>
                    </div>
                    <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-fresh-4" name="fresh_items" value="16500" tabindex="0">
                        <label for="chk-fresh-4" id="lbl-fresh-4">노르웨이산 생연어 필렛 300 그램 16,500 원</label>
                    </div>
                    <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-fresh-5" name="fresh_items" value="5800" tabindex="0">
                        <label for="chk-fresh-5" id="lbl-fresh-5">동물복지 유정란 10구 5,800 원</label>
                    </div>
                     <div class="modal-footer">
                         <button type="button" id="btn-next-from-fresh" class="btn btn-next" tabindex="0">다음</button>
                     </div>
                </form>
            </div>
        </div>

        <div id="modal-dairy" class="modal" aria-hidden="true" role="dialog" aria-label="요거트/유제품 카테고리">
             <div class="modal-content">
                 <button id="btn-back-from-dairy" class="btn btn-back invisible-but-interactive" tabindex="0">뒤로가기</button>
                 <h1 class="invisible-but-interactive" tabindex="0">요거트/유제품 카테고리</h1>
                 <form id="form-dairy">
                    <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-dairy-1" name="dairy_items" value="6900" tabindex="0">
                        <label for="chk-dairy-1" id="lbl-dairy-1">무가당 플레인 그릭 요거트 450 그램 6,900 원</label>
                    </div>
                    <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-dairy-2" name="dairy_items" value="3200" tabindex="0">
                        <label for="chk-dairy-2" id="lbl-dairy-2">떠먹는 딸기 요거트 85g*4 입 3,200 원</label>
                    </div>
                    <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-dairy-3" name="dairy_items" value="2950" tabindex="0">
                        <label for="chk-dairy-3" id="lbl-dairy-3">1등급 저지방 우유 900 밀리리터 2,950 원</label>
                    </div>
                    <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-dairy-4" name="dairy_items" value="5200" tabindex="0">
                        <label for="chk-dairy-4" id="lbl-dairy-4">간편 슬라이스 체다 치즈 270 그램 5,200 원</label>
                    </div>
                    <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-dairy-5" name="dairy_items" value="3800" tabindex="0">
                        <label for="chk-dairy-5" id="lbl-dairy-5">사과맛 요구르트 150 밀리리터 3,800 원</label>
                    </div>
                     <div class="modal-footer">
                         <button type="button" id="btn-next-from-dairy" class="btn btn-next" tabindex="0">다음</button>
                    </div>
                 </form>
            </div>
        </div>

        <div id="modal-fastfood" class="modal" aria-hidden="true" role="dialog" aria-label="패스트푸드 카테고리">
            <div class="modal-content">
                <button id="btn-back-from-fastfood" class="btn btn-back invisible-but-interactive" tabindex="0">뒤로가기</button>
                <h1 class="invisible-but-interactive" tabindex="0">패스트푸드 카테고리</h1>
                <form id="form-fastfood">
                    <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-fastfood-1" name="fastfood_items" value="4500" tabindex="0">
                        <label for="chk-fastfood-1" id="lbl-fastfood-1">오리지널 비프 치즈버거 200그램 4,500 원</label>
                    </div>
                    <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-fastfood-2" name="fastfood_items" value="7900" tabindex="0">
                        <label for="chk-fastfood-2" id="lbl-fastfood-2">콤비네이션 냉동 피자 한판 450그램 7,900 원</label>
                    </div>
                    <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-fastfood-3" name="fastfood_items" value="11500" tabindex="0">
                        <label for="chk-fastfood-3" id="lbl-fastfood-3">바삭한 후라이드 치킨 순살 500그램 11,500 원</label>
                    </div>
                    <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-fastfood-4" name="fastfood_items" value="6500" tabindex="0">
                        <label for="chk-fastfood-4" id="lbl-fastfood-4">베이컨 토마토 디럭스 햄버거 350 그램 6,500 원</label>
                    </div>
                    <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-fastfood-5" name="fastfood_items" value="7800" tabindex="0">
                        <label for="chk-fastfood-5" id="lbl-fastfood-5">모짜렐라 크리스피 핫도그 5개입 425그램 7,800 원</label>
                    </div>
                    <div class="modal-footer">
                        <button type="button" id="btn-next-from-fastfood" class="btn btn-next" tabindex="0">다음</button>
                    </div>
                </form>
            </div>
        </div>

        <div id="modal-seafood" class="modal" aria-hidden="true" role="dialog" aria-label="수산물 카테고리">
             <div class="modal-content">
                <button id="btn-back-from-seafood" class="btn btn-back invisible-but-interactive" tabindex="0">뒤로가기</button>
                <h1 class="invisible-but-interactive" tabindex="0">수산물 카테고리</h1>
                 <form id="form-seafood">
                     <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-seafood-1" name="seafood_items" value="6900" tabindex="0">
                        <label for="chk-seafood-1" id="lbl-seafood-1">국내산 손질 고등어 특대 2마리 (400그램 내외) 6,900 원</label>
                    </div>
                    <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-seafood-2" name="seafood_items" value="12000" tabindex="0">
                        <label for="chk-seafood-2" id="lbl-seafood-2">동해안 생물 오징어 3마리 (600그램 내외) 12,000 원</label>
                    </div>
                    <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-seafood-3" name="seafood_items" value="22500" tabindex="0">
                        <label for="chk-seafood-3" id="lbl-seafood-3">자연산 냉동 흰다리새우 1킬로그램 22,500 원</label>
                    </div>
                    <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-seafood-4" name="seafood_items" value="8500" tabindex="0">
                        <label for="chk-seafood-4" id="lbl-seafood-4">국산 활 바지락 1킬로그램 8,500 원</label>
                    </div>
                    <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-seafood-5" name="seafood_items" value="11900" tabindex="0">
                        <label for="chk-seafood-5" id="lbl-seafood-5">노르웨이산 생연어회 슬라이스 180그램 11,900 원</label>
                    </div>
                    <div class="modal-footer">
                        <button type="button" id="btn-next-from-seafood" class="btn btn-next" tabindex="0">다음</button>
                    </div>
                 </form>
            </div>
        </div>

        <div id="modal-processed" class="modal" aria-hidden="true" role="dialog" aria-label="가공식품 카테고리">
            <div class="modal-content">
                <button id="btn-back-from-processed" class="btn btn-back invisible-but-interactive" tabindex="0">뒤로가기</button>
                <h1 class="invisible-but-interactive" tabindex="0">가공식품 카테고리</h1>
                 <form id="form-processed">
                     <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-processed-1" name="processed_items" value="6700" tabindex="0">
                        <label for="chk-processed-1" id="lbl-processed-1">마일드 참치캔 150그램 4개 묶음 6,700 원</label>
                    </div>
                    <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-processed-2" name="processed_items" value="5300" tabindex="0">
                        <label for="chk-processed-2" id="lbl-processed-2">짜지 않은 리치팜 햄 340그램 5,300 원</label>
                    </div>
                    <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-processed-3" name="processed_items" value="4800" tabindex="0">
                        <label for="chk-processed-3" id="lbl-processed-3">얼큰한 해물맛 라면 5개입 4,800 원</label>
                    </div>
                    <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-processed-4" name="processed_items" value="1900" tabindex="0">
                        <label for="chk-processed-4" id="lbl-processed-4">3분 비프 카레 순한맛 200그램 1,900 원</label>
                    </div>
                    <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-processed-5" name="processed_items" value="6900" tabindex="0">
                        <label for="chk-processed-5" id="lbl-processed-5">종가집 맛김치 500그램 6,900 원</label>
                    </div>
                    <div class="modal-footer">
                        <button type="button" id="btn-next-from-processed" class="btn btn-next" tabindex="0">다음</button>
                    </div>
                 </form>
            </div>
        </div>

        <div id="modal-icecream" class="modal" aria-hidden="true" role="dialog" aria-label="아이스크림 카테고리">
             <div class="modal-content">
                <button id="btn-back-from-icecream" class="btn btn-back invisible-but-interactive" tabindex="0">뒤로가기</button>
                <h1 class="invisible-but-interactive" tabindex="0">아이스크림 카테고리</h1>
                 <form id="form-icecream">
                     <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-icecream-1" name="icecream_items" value="9500" tabindex="0">
                        <label for="chk-icecream-1" id="lbl-icecream-1">달콤 초코칩 아이스크림 파인트 474밀리리터 9,500 원</label>
                    </div>
                    <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-icecream-2" name="icecream_items" value="6200" tabindex="0">
                        <label for="chk-icecream-2" id="lbl-icecream-2">상큼 딸기 아이스 바 10개입 6,200 원</label>
                    </div>
                    <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-icecream-3" name="icecream_items" value="7500" tabindex="0">
                        <label for="chk-icecream-3" id="lbl-icecream-3">바삭 초코 크런치 아이스크림 콘 5개입 7,500 원</label>
                    </div>
                    <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-icecream-4" name="icecream_items" value="2000" tabindex="0">
                        <label for="chk-icecream-4" id="lbl-icecream-4">부드러운 쿠키 앤 크림 아이스 샌드 150밀리리터 2,000 원</label>
                    </div>
                    <div class="checkbox-item invisible-but-interactive">
                        <input type="checkbox" id="chk-icecream-5" name="icecream_items" value="8800" tabindex="0">
                        <label for="chk-icecream-5" id="lbl-icecream-5">미니 아이스크림 골라담기 8개 세트 8,800 원</label>
                    </div>
                     <div class="modal-footer">
                        <button type="button" id="btn-next-from-icecream" class="btn btn-next" tabindex="0">다음</button>
                    </div>
                </form>
            </div>
        </div>

    </div> <script>
    (function() {
      'use strict';

      /**
       * 1. SpeechManager: 음성 출력 관리 (업데이트된 버전)
       */
      const SpeechManager = {
        synth: window.speechSynthesis,
        utterance: null,
        voices: [], // 사용 가능한 음성 목록 저장
        koreanVoice: null, // 선택된 한국어 음성 저장
        speaking: false,
        queue: [],
        lastFocusText: '',
        isSpeakingAlert: false,

        init: function() {
          if (!this.synth) {
             console.error('Speech Synthesis API가 지원되지 않습니다.');
             alert('이 브라우저에서는 음성 기능을 사용할 수 없습니다.');
             return false;
          }

          this.utterance = new SpeechSynthesisUtterance();
          this.utterance.pitch = 1;
          this.utterance.rate = 1; // 속도 조절 필요 시 값 변경
          this.utterance.volume = 1;

          this.utterance.onstart = () => { this.speaking = true; };
          this.utterance.onend = () => {
            this.speaking = false;
            this.isSpeakingAlert = false;
            this.processQueue();
          };
          this.utterance.onerror = (event) => {
            console.error('Speech Synthesis 오류:', event.error);
            this.speaking = false;
            this.isSpeakingAlert = false;
            this.queue = [];
          };

          // --- 한국어 음성 로드 및 설정 로직 ---
          const loadVoices = () => {
            this.voices = this.synth.getVoices();
            // console.log("사용 가능한 음성 목록:", this.voices); // 디버깅 필요시 주석 해제

            // 한국어 음성 찾기 (ko-KR) - default 또는 localService 우선
            this.koreanVoice = this.voices.find(voice => voice.lang === 'ko-KR' && voice.default);
             if (!this.koreanVoice) {
                this.koreanVoice = this.voices.find(voice => voice.lang === 'ko-KR' && voice.localService);
             }
             if (!this.koreanVoice) { // 로컬/기본 없으면 그냥 첫번째 ko-KR 찾기
                 this.koreanVoice = this.voices.find(voice => voice.lang === 'ko-KR');
             }

            if (this.koreanVoice) {
              console.log("선택된 한국어 음성:", this.koreanVoice.name, this.koreanVoice.lang);
              this.utterance.voice = this.koreanVoice;
              // voice 객체 설정 후에도 lang 속성 설정 권장 (특히 iOS)
              this.utterance.lang = this.koreanVoice.lang; // 'ko-KR' 대신 찾은 voice의 lang 사용
            } else {
              console.warn("사용 가능한 한국어 음성을 찾지 못했습니다. lang='ko-KR' 설정에 의존합니다.");
              // 한국어 음성이 없어도 lang 설정은 유지
              this.utterance.lang = 'ko-KR';
            }
          };

          // 음성 목록은 비동기적으로 로드될 수 있음
          loadVoices(); // 초기 시도
          if (this.synth.onvoiceschanged !== undefined) {
            // onvoiceschanged 이벤트가 발생하면 다시 음성 로드/설정 시도
            this.synth.onvoiceschanged = loadVoices;
          }
          // --- 음성 로드 로직 끝 ---

          console.log("SpeechManager 초기화 완료");
          return true;
        },

        speak: function(text, priority = false) {
            if (!text || !this.utterance) return;

            if (!priority && text === this.lastFocusText && !this.isSpeakingAlert) {
                return;
            }

            if (this.speaking) {
                if (priority || !this.isSpeakingAlert) {
                    this.synth.cancel();
                    this.speaking = false;
                    this.isSpeakingAlert = false;
                    this.queue = [];
                    setTimeout(() => this._executeSpeak(text, priority), 50); // cancel 후 약간의 지연
                    return;
                } else {
                    // 현재 알림 말하는 중이면, 중복되지 않게 큐에 추가
                    if (!this.queue.find(item => item.text === text)) {
                        this.queue.push({ text, priority });
                    }
                    return;
                }
            } else {
                this._executeSpeak(text, priority);
            }
        },

        _executeSpeak: function(text, priority) {
            if (!text || !this.utterance) return;
            this.utterance.text = text;
            this.isSpeakingAlert = priority;

            if (!priority) {
                this.lastFocusText = text;
            }
            // console.log(`실제 발화: "${text}" using voice: ${this.utterance.voice?.name}, lang: ${this.utterance.lang}`);
            try {
                this.synth.speak(this.utterance);
            } catch (error) {
                 console.error("synth.speak() 오류 발생:", error);
                 // 오류 발생 시 상태 리셋
                 this.speaking = false;
                 this.isSpeakingAlert = false;
            }
        },

        processQueue: function() {
          if (this.queue.length > 0 && !this.speaking) {
            const nextUtterance = this.queue.shift();
            this.speak(nextUtterance.text, nextUtterance.priority);
          }
        },

        speakElementInfo: function(element) {
          if (!element) return;
          let textToSpeak = '';
          let elementType = '';
          const tagName = element.tagName.toLowerCase();
          const typeAttr = element.getAttribute('type');

          try {
            if (tagName === 'h1') { elementType = ''; textToSpeak = element.textContent?.trim() || '제목 없음'; }
            else if (tagName === 'button') { elementType = '버튼'; textToSpeak = element.textContent?.trim() || '버튼'; }
            else if (tagName === 'input' && typeAttr === 'checkbox') {
              elementType = '체크박스';
              const label = document.querySelector(`label[for="${element.id}"]`);
              const labelText = label?.textContent?.trim() || '체크박스 항목';
              const isChecked = element.checked ? '선택됨' : '선택 안됨';
              textToSpeak = `${labelText}, ${isChecked}`;
            } else if (tagName === 'label') {
                const checkboxId = element.getAttribute('for');
                const checkbox = checkboxId ? document.getElementById(checkboxId) : null;
                if (checkbox && checkbox.type === 'checkbox') {
                    elementType = '체크박스';
                    const labelText = element.textContent?.trim() || '체크박스 항목';
                    const isChecked = checkbox.checked ? '선택됨' : '선택 안됨';
                    textToSpeak = `${labelText}, ${isChecked}`;
                } else { textToSpeak = element.textContent?.trim(); }
            } else { textToSpeak = element.textContent?.trim() || element.getAttribute('aria-label') || '요소'; }

            const fullText = elementType ? `${textToSpeak} ${elementType}` : textToSpeak;
            this.speak(fullText);
          } catch (error) {
              console.error("speakElementInfo 오류:", error, "대상 요소:", element);
              this.speak("요소 정보를 읽는 중 오류가 발생했습니다.");
          }
        },

        alert: function(message) {
          if (!message) return;
          this.speak(message, true);

          const alertContainer = document.getElementById('alert-container');
          if (alertContainer) {
            alertContainer.textContent = message;
            alertContainer.style.display = 'block';
            setTimeout(() => { alertContainer.style.display = 'none'; }, 3000);
          }
        }
      }; // End of SpeechManager

      /**
       * 2. FocusManager: 초점 관리
       */
      const FocusManager = {
        focusableElements: [],
        currentFocusIndex: -1,
        currentContainer: null,

        init: function() {
          this.setCurrentContainer(document.getElementById('home-screen'), true);
          console.log("FocusManager 초기화 완료");
        },

        setCurrentContainer: function(container, setInitialFocus = false) {
          if (!container) {
            console.error("setCurrentContainer: 유효하지 않은 컨테이너입니다.");
            return;
          }
          this.currentContainer = container;
          this.findFocusableElements();

          if (setInitialFocus && this.focusableElements.length > 0) {
            this.setFocus(0);
          } else {
             this.currentFocusIndex = -1;
             this.removeFocusHighlight();
          }
        },

        findFocusableElements: function() {
          if (!this.currentContainer) return;
          const selector = 'h1[tabindex="0"], button[tabindex="0"], input[type="checkbox"][tabindex="0"]';
          this.focusableElements = Array.from(this.currentContainer.querySelectorAll(selector))
                .filter(el => el.offsetParent !== null || el.closest('.modal.modal-open'));
           this.currentFocusIndex = -1;
        },

        setFocus: function(index) {
          if (index < 0 || index >= this.focusableElements.length) {
            return;
          }
          this.removeFocusHighlight();
          this.currentFocusIndex = index;
          const element = this.focusableElements[index];

          if (element) {
            element.classList.add('has-focus');
            // console.log("포커스 설정:", index, element.id || element.tagName); // 디버깅 필요시 주석 해제
            SpeechManager.speakElementInfo(element);
          } else {
             console.error(`setFocus: 인덱스 ${index}에 해당하는 요소를 찾을 수 없습니다.`);
             this.currentFocusIndex = -1;
          }
        },

        setFocusOnElement: function(element) {
          if (!element) return;
          const index = this.focusableElements.indexOf(element);
          if (index !== -1) {
            this.setFocus(index);
          }
        },

        moveFocus: function(direction) {
          if (this.focusableElements.length === 0) return;
          const newIndex = this.currentFocusIndex + direction;

          if (newIndex < 0) {
            SpeechManager.alert('첫 번째 항목입니다'); return;
          }
          if (newIndex >= this.focusableElements.length) {
            SpeechManager.alert('마지막 항목입니다'); return;
          }
          this.setFocus(newIndex);
        },

        getCurrentElement: function() {
          if (this.currentFocusIndex >= 0 && this.currentFocusIndex < this.focusableElements.length) {
            return this.focusableElements[this.currentFocusIndex];
          }
          return null;
        },

        setFocusByTouch: function(x, y) {
          const element = document.elementFromPoint(x, y);
          if (!element) return;
          let focusableTarget = this.findFocusableParent(element);
          if (focusableTarget && this.focusableElements.includes(focusableTarget)) {
             this.setFocusOnElement(focusableTarget);
          }
        },

        findFocusableParent: function(element) {
          let current = element;
          while (current && current !== document.body) {
            if (this.focusableElements.includes(current)) { return current; }
             if (current.classList.contains('checkbox-item')) {
                 const checkbox = current.querySelector('input[type="checkbox"][tabindex="0"]');
                 if (checkbox && this.focusableElements.includes(checkbox)) { return checkbox; }
             }
            current = current.parentElement;
          }
          return null;
        },

        removeFocusHighlight: function() {
             if (this.currentFocusIndex >= 0 && this.currentFocusIndex < this.focusableElements.length) {
                 const prevElement = this.focusableElements[this.currentFocusIndex];
                 if(prevElement) { prevElement.classList.remove('has-focus'); }
             }
        }
      }; // End of FocusManager

      /**
       * 3. TouchGestureManager: 터치 제스처 감지 및 처리
       */
      const TouchGestureManager = {
        startX: 0, startY: 0, startTime: 0,
        lastTapTime: 0, lastTapX: 0, lastTapY: 0,
        isDragging: false,

        doubleTapDelay: 200,
        doubleTapDistance: 30,
        swipeThreshold: 50,
        swipeTimeLimit: 500,
        moveThreshold: 10,

        init: function() {
          const touchTarget = document.getElementById('app-container');
          touchTarget.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
          touchTarget.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
          touchTarget.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });
          touchTarget.addEventListener('touchcancel', this.handleTouchCancel.bind(this), { passive: false });
          console.log("TouchGestureManager 초기화 완료");
        },

        handleTouchStart: function(e) {
          if (e.touches.length > 1) { this.isDragging = false; return; }
          // 기본 동작 방지 (input 등 예외 처리 필요시 추가)
          if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
             e.preventDefault();
          }

          const touch = e.touches[0];
          this.startX = touch.clientX;
          this.startY = touch.clientY;
          this.startTime = Date.now();
          this.isDragging = false;
        },

        handleTouchMove: function(e) {
           if (e.touches.length > 1) return;
           const touch = e.touches[0];
           const deltaX = touch.clientX - this.startX;
           const deltaY = touch.clientY - this.startY;
           if (!this.isDragging && (Math.abs(deltaX) > this.moveThreshold || Math.abs(deltaY) > this.moveThreshold)) {
               this.isDragging = true;
           }
           if (this.isDragging) { e.preventDefault(); } // 드래그 시작하면 기본 동작 방지
        },

        handleTouchEnd: function(e) {
          if (e.changedTouches.length !== 1) { this.resetTouchState(); return; }

          const touch = e.changedTouches[0];
          const endX = touch.clientX;
          const endY = touch.clientY;
          const endTime = Date.now();
          const deltaTime = endTime - this.startTime;
          const deltaX = endX - this.startX;
          const deltaY = endY - this.startY;

          const timeSinceLastTap = endTime - this.lastTapTime;
          const distanceSinceLastTap = Math.hypot(endX - this.lastTapX, endY - this.lastTapY);

          // 더블 탭 확인
          if (!this.isDragging && timeSinceLastTap < this.doubleTapDelay && distanceSinceLastTap < this.doubleTapDistance) {
            this.handleDoubleTap();
            this.resetTouchState(); // 더블 탭 후 상태 초기화
            e.preventDefault();
            return;
          }

          // 마지막 탭 정보 업데이트 (더블 탭 아니었을 경우)
          this.lastTapTime = endTime;
          this.lastTapX = endX;
          this.lastTapY = endY;

          // 스와이프 확인
          const isHorizontalSwipe = Math.abs(deltaX) > Math.abs(deltaY);
          const isSwipeDistance = Math.abs(deltaX) > this.swipeThreshold;
          if (this.isDragging && deltaTime < this.swipeTimeLimit && isHorizontalSwipe && isSwipeDistance) {
            const direction = deltaX > 0 ? 'right' : 'left';
            this.handleSwipe(direction);
            e.preventDefault();
          }
          // 단일 탭 확인
          else if (!this.isDragging && deltaTime < this.swipeTimeLimit) {
             FocusManager.setFocusByTouch(endX, endY);
             e.preventDefault();
          }
          this.isDragging = false; // 터치 종료 시 드래그 상태 리셋
        },

        handleTouchCancel: function(e) { this.resetTouchState(); },
        resetTouchState: function() { /* 이전과 동일 */ },

        handleDoubleTap: function() {
          const currentElement = FocusManager.getCurrentElement();
          if (!currentElement) return;

          if (currentElement.tagName === 'BUTTON') {
            currentElement.click();
          } else if (currentElement.tagName === 'INPUT' && currentElement.type === 'checkbox') {
            const checkbox = currentElement;
            const form = checkbox.closest('form');
            let allowToggle = true;
            if (!checkbox.checked && form) {
              const otherChecked = form.querySelector('input[type="checkbox"]:checked');
              if (otherChecked && otherChecked !== checkbox) {
                SpeechManager.alert('이미 하나의 상품을 선택하셨습니다');
                allowToggle = false;
              }
            }
            if (allowToggle) {
              checkbox.checked = !checkbox.checked;
              SpeechManager.speakElementInfo(checkbox);
              const event = new Event('change', { bubbles: true });
              checkbox.dispatchEvent(event);
            }
          }
        },
        handleSwipe: function(direction) {
          if (direction === 'right') { FocusManager.moveFocus(1); }
          else if (direction === 'left') { FocusManager.moveFocus(-1); }
        }
      }; // End of TouchGestureManager

      /**
       * 4. AppStateManager: 애플리케이션 상태 및 흐름 관리
       */
      const AppStateManager = {
        activeModal: null,
        googleFormUrl: 'https://docs.google.com/forms/d/e/1FAIpQLSdGuFNDeGYBBHT9Dby7o5Yp0YAmxxwg3njEfaR7uP1JYJipFw/viewform?entry.1867939657=',

        init: function() {
          this.setupCategoryButtons();
          this.setupBackButtons();
          this.setupNextButtons();
          this.setupCheckboxes();
          console.log("AppStateManager 초기화 완료");
        },

        setupCategoryButtons: function() {
          document.querySelectorAll('.category-buttons .btn').forEach(button => {
            button.addEventListener('click', (e) => {
              const categoryId = button.id.split('-').pop();
              if (categoryId) { this.openModal(categoryId); }
            });
          });
        },

        setupBackButtons: function() {
          document.querySelectorAll('.btn-back').forEach(button => {
            button.addEventListener('click', (e) => { this.closeModal(); });
          });
        },

        setupNextButtons: function() {
          document.querySelectorAll('.btn-next').forEach(button => {
            button.addEventListener('click', (e) => {
                const form = button.closest('form');
                if (form) { this.handleNextButton(form); }
            });
          });
        },

        setupCheckboxes: function() {
          document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', (e) => {
              const currentCheckbox = e.target;
              const form = currentCheckbox.closest('form');
              if (form && currentCheckbox.checked) {
                form.querySelectorAll('input[type="checkbox"]').forEach(otherCheckbox => {
                  if (otherCheckbox !== currentCheckbox && otherCheckbox.checked) {
                    otherCheckbox.checked = false;
                  }
                });
              }
            });
          });
        },

        openModal: function(categoryId) {
          const modalToOpen = document.getElementById(`modal-${categoryId}`);
          if (!modalToOpen) { console.error(`모달 찾기 실패: modal-${categoryId}`); return; }
          if (this.activeModal && this.activeModal !== modalToOpen) { this.closeModal(); }

          modalToOpen.classList.add('modal-open');
          modalToOpen.setAttribute('aria-hidden', 'false');
          document.getElementById('app-container').classList.add('modal-active');
          this.activeModal = modalToOpen;
          FocusManager.setCurrentContainer(modalToOpen, true);
        },

        closeModal: function() {
          if (!this.activeModal) return;
          const closedModalId = this.activeModal.id;
          this.activeModal.classList.remove('modal-open');
          this.activeModal.setAttribute('aria-hidden', 'true');
          document.getElementById('app-container').classList.remove('modal-active');
          this.activeModal = null;

          const homeScreen = document.getElementById('home-screen');
          FocusManager.setCurrentContainer(homeScreen);
          // 포커스 복원 시도
          const categoryButtonId = `btn-category-${closedModalId.split('-').pop()}`;
          const categoryButton = document.getElementById(categoryButtonId);
          if (categoryButton && FocusManager.focusableElements.includes(categoryButton)) {
             FocusManager.setFocusOnElement(categoryButton);
          } else if (FocusManager.focusableElements.length > 0) {
             FocusManager.setFocus(0); // 홈 첫 요소로
          }
        },

        handleNextButton: function(form) {
          const checkedBox = form.querySelector('input[type="checkbox"]:checked');
          if (!checkedBox) {
            SpeechManager.alert('상품을 선택해주세요'); return;
          }
          const price = checkedBox.value;
          if (!price) {
             console.error("선택된 상품 가격(value) 없음");
             SpeechManager.alert("선택된 상품 정보를 가져올 수 없습니다."); return;
          }
          const finalUrl = this.googleFormUrl + encodeURIComponent(price);
          // console.log("Google Form 이동:", finalUrl); // 디버깅 필요시 주석 해제
          window.location.href = finalUrl;
        }
      }; // End of AppStateManager

      // --- 애플리케이션 초기화 ---
      function initApp() {
        console.log("애플리케이션 초기화 시작...");
        if (!SpeechManager.init()) {
            console.error("SpeechManager 초기화 실패. 앱 기능 제한됨."); return;
        }
        FocusManager.init();
        TouchGestureManager.init();
        AppStateManager.init();
        console.log("애플리케이션 초기화 완료.");
      }

      document.addEventListener('DOMContentLoaded', initApp);

    })();
    </script>

</body>
</html>